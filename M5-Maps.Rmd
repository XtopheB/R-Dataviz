---
title: "Create (beautiful) maps with R"
author: "Christophe Bontemps (UN SIAP)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    highlight: tango
    number_sections: yes
    theme: lumen
  html_notebook: default
  pdf_document:
    keep_tex: yes
  word_document: default
---


```{r setup, include=FALSE}
# Remeber to disable png for Word export...
knitr::opts_chunk$set( message = FALSE, warning = FALSE, 
                       results =FALSE, echo = FALSE,
                       dev="png", 
                       dev.args=list(type="cairo"), dpi=96)

# My colors:
SIAP.color <- "#0385a8"

# Function used to recreate ggplot standard colors
ggplotColours <- function(n = 6, h = c(0, 360) + 15){
  if ((diff(h) %% 360) < 1) h[2] <- h[2] - 360/n
  hcl(h = (seq(h[1], h[2], length = n)), c = 100, l = 65)
}

```


```{r libraries}
library(tidyverse)
library(viridis)
library(ggthemes)
library(ggplot2)
library(forcats)
library(knitr)
library(kableExtra)

```
# Useful sources {-}

* [**Fundamentals of Data Visualization**](https://clauswilke.com/dataviz/index.html) by Claus O. Wilke
* [**Geocomputation with R**](https://geocompr.robinlovelace.net/index.html) Robin Lovelace, Jakub Nowosad, Jannes Muenchow, a,d in particular the chapter [*Making maps with R*](https://geocompr.robinlovelace.net/adv-map.html) 
* Kieran Healy's [**Data Visualization book**](https://socviz.co/maps.html#maps) chapter on maps

### On ggplot{-}

[ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/maps.html) by Hadley Wickham


## Data sets {-}
We use the data from  [Natural Earth Data](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-countries/) for 
*all countries*, and in particular the shapefiles *ne_10m_admin_0_countries.shp*


# Using the shape files and the *sf* library

*We use the tutorial provided by [Atlan](https://atlan.com/courses/introduction-to-gis-r/lesson2-manipulating-geospatial-data/)*


The *sf* (Simple Features) package is the successor to the *sp* package. It allows to work in the *tidy* framework using spatial data frames. Therefore, one can use the pipe an other tidy tools to  manipulate an sf object like an ordinary data frame, or at least one with a few special characteristics.


```{r Data}
library(sf)

#loading Shapefiles
library(sf)
my_sf <- st_read("Data/Maps/ne_10m_admin_0_countries/ne_10m_admin_0_countries.shp")

glimpse(my_sf)

```


```{r }
st_crs(my_sf)

```


> One can extract only the geometry from the Spatial data.frame to see the shapes of the map

```{r}
# Extract only the geometry with sf:st_geometry

my_geometry <- st_geometry(my_sf)
plot(my_geometry, main = "Map Geometry")


```

There are many information already in the shapefile, we can plot all of them here...

```{r}
plot(my_sf)
```

... or just one... 

```{r}
plot(my_sf["POP_EST"], 
     key.pos = 1,
     key.width = lcm(1.3), 
     key.length = 0.5,
     main = "Population (est. 2017)")
```

... or part of it..

```{r}
my_asia <- my_sf %>%
  filter(CONTINENT == "Asia" )

plot(my_asia["POP_EST"], 
     key.pos = 1,
     key.width = lcm(1.3), 
     key.length = 0.5,
     main = "Population (est. 2017)")

```


# Merging Spatial data sets

Here we already have a spatial data object that has its own projection system ( `r st_crs(my_sf)[1]`). We will merge this  spatial data frame  with a data set where the SDG indicator of interest (5.5.1) is recorded at the at the country level. The merging variable will be the name of the country, so there is no need here to worry about the projection  and the adjustment of the spatial units reference since only one file is using a projection system.   

```{r}
my_sdg <- read.csv("Data/Maps/SG_GEN_PARL_ap.csv", sep = ",")
sdg_label <- "Seats held by women in national parliaments (%)"


```


```{r}
# Keeping only esential values in the ShapeFile dataset
# my_asia_reduced <- my_asia  %>%
#   select("ADMIN", "NAME", "NAME_LONG")


my_geodata <- merge(my_sf, my_sdg, by.x= "NAME_LONG", by.y = "GeoAreaName")  %>%
  st_crop(c(xmin= -50, xmax = 500, ymin = -50,  ymax = 70))


```

# Choropleth Maps 

## with *sf*

```{r}
plot(my_geodata["X2019"], 
     key.pos = 1,
     key.width = lcm(1.3), 
     key.length = 0.5, 
     main = sdg_label, 
     sub = "(SDG indic. 5.5.1)")
```

### Adjusting the breaks{-}

Here we clearly see that the colors applied to the map do not help understanding the various *levels$* of percentages for each country. 
We can change the numbers of categories, the colors and length of each color category used for doing this map.  

```{r}
# breaks using quintiles 

my_nb_breaks <- 5

plot(my_geodata["X2019"], 
     nbreaks = my_nb_breaks,
     breaks = "jenks",
     pal = heat.colors(my_nb_breaks),
     key.pos = 1,
     key.width = lcm(1.4), 
     key.length = 0.5, 
     main = sdg_label
     )

```


## With ggplot 

ggplot can easily represent an *sf* object and represent it as it would for any data frame using the **geom_sf**. By default, since the variable is continuous, *ggplot* uses a **continuous color palette**

```{r}
library(ggplot2)
ggplot(my_geodata) + 
  geom_sf(aes(fill = X2019)) +
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")
```
### A few improvements... {-}

```{r}
 ggplot(my_geodata) + 
  geom_sf(aes(fill = X2019)) +
  ggtitle(sdg_label) +
  theme_minimal() +
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme(legend.position = "bottom", 
        legend.title = element_text(color = "#235a91", size = 10))
```

### Changing the map projection {-} 

```{r}
ggplot(my_geodata) + 
  geom_sf(aes(fill = X2019)) +
  ggtitle(sdg_label) +
  theme_minimal() +
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme(legend.position = "bottom", 
        legend.title = element_text(color = "#235a91", size = 10)) +
  coord_sf(crs = st_crs(3112))
  
```

### Changing the break points and number of categories...

#### Break points can be based on quantiles...{-}

```{r}
# Defining the nb of classes and breakpoints
nb_classes <- 8
```

Here with *`r nb_classes`* classes

```{r}
my_breaks <- quantile(my_geodata$X2019,
                      probs = seq(0, 1, length.out = nb_classes + 1),
                      na.rm = TRUE)
# Customize the labels
my_breaks_labels <-  c()
for(idx in 1:length(my_breaks)){
my_breaks_labels <- c(my_breaks_labels, paste0(round(my_breaks[idx], 0), 
                             " – ", 
                             round(my_breaks[idx + 1], 0)))
}
# I need to remove the last label 
# because that would be something like "66.62 - NA"
my_breaks_labels <- my_breaks_labels[1:length(my_breaks_labels)-1]

## We have to trasform the percentatges into a categorical variable. 
my_geodata %>%
  mutate(
    my_class = cut(X2019, 
                   breaks = my_breaks,
                   labels = my_breaks_labels, 
                   include.lowest = T))   %>%
ggplot() + 
  geom_sf(aes(fill = my_class)) +
  # We may use a different color palette
  #scale_fill_viridis(discrete = T)+
  ggtitle(sdg_label) + 
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme_minimal() +
  theme(legend.position = "bottom", 
        legend.title = element_text(color = "#235a91", size = 10))
  
```

#### Break points can be based on anything else {-}

```{r}
# Defining the nb of classes and breakpoints
nb_classes <- 8
my_breaks <- quantile(my_geodata$X2019,
                      probs = seq(0, 1, length.out = nb_classes + 1),
                      na.rm = TRUE)

my_breaks <-  seq(0, max(my_geodata$X2019, na.rm=T),
                  length.out = nb_classes + 1)
                    

# Customize the labels (rounding basically)
my_breaks_labels <-  c()
for(idx in 1:length(my_breaks)){
my_breaks_labels <- c(my_breaks_labels, paste0(round(my_breaks[idx], 0), 
                             " – ", 
                             round(my_breaks[idx + 1], 0)))
}
my_breaks_labels <- my_breaks_labels[1:length(my_breaks_labels)-1]

## We have to trasform the percentatges into a categorical variable. 
my_geodata %>%
  mutate(
    my_class = cut(X2019, 
                   breaks = my_breaks,
                   labels = my_breaks_labels, 
                   include.lowest = T))   %>%
ggplot() + 
  geom_sf(aes(fill = my_class)) +
  # We may use a different color palette
  #scale_fill_viridis(discrete = T)+
  ggtitle(sdg_label) + 
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme_minimal() +
  theme(legend.position = "bottom", 
        legend.title = element_text(color = "#235a91", size = 10))
  
```

# Proportionnal symbol maps 
## Bubble charts) with ggplot

```{r}
# we need to have the lat and logitude of each countries to be able to place the circles (points) 
world_data <- map_data("world") %>%
  select(region, lat, long) %>%
  group_by(region) %>%
  mutate(my_lat = median(lat, na.rm = TRUE), 
         my_long = median(long, na.rm = TRUE)) %>%
  distinct(region,my_lat, my_long, .keep_all = TRUE) %>%
  filter(
    long >50
  )
# Adding this information to my spatial data set
my_geodata_world <- merge(my_geodata, world_data, by.x= "NAME_LONG", by.y = "region")


my_geodata_world %>%
ggplot() + 
 geom_sf( color = "grey", fill = "white") +
 geom_point(aes(x=my_long, y=my_lat, size= X2019),
            color = SIAP.color ,
            stroke=F, 
            alpha=0.5) +

  ggtitle(sdg_label) + 
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme_minimal() +
  theme(legend.position = "bottom",
        legend.title = element_text(color = SIAP.color, size = 10))
```

### Caveat! {-} 

For *geom_point*, the size parameter scales **both** the x and y dimension of the point
proportionately. So a value that is double than another will have its surface multiplied by 4
Hence, the size of the points in R are proportional to its $radius^2$ . This is not a good way to practice!

```{r}
ggplot(data.frame(x     = 0, 
                  y     = 0, 
                  panel = c("A", "B", "C"), 
                  value = c(10, 20, 40))) + 
  geom_point(aes(x, y, size = value), color = SIAP.color) +
  coord_cartesian(xlim = c(-10, 10), ylim = c(-10,10)) +
  scale_y_continuous(breaks = c(-5, -2.5, 0, 2.5,5)) +
  scale_size_identity() +
  facet_wrap(.~panel) +
  theme_minimal() +
  theme(panel.grid.minor.x = element_blank())
```
 

### Solution: Compute the right value and plot the surface  {-}

```{r}
my_geodata_world %>%
  mutate(area_X2019 = sqrt(X2019))%>%
ggplot() + 
 geom_sf( color = "grey", fill = "white") +
 geom_point(aes(x=my_long, y=my_lat, size= area_X2019),
            color = SIAP.color ,
            alpha=0.5) +
  scale_size_area() +
  ggtitle(sdg_label) + 
  labs(fill = "Perc. of women \n(Indic. 5.5.1)")+
  theme_minimal() +
  theme(legend.position = "bottom",
        legend.title = element_text(color = SIAP.color, size = 10))
```


## *Real* cartography packages:  *tmap* or *cartography*





```{r}
knitr::knit_exit()
```



```{r}
## regions Colors
#my_cols <- c("#00AFBB", "#E7B800", "#FC4E07") 
#my_cols <-c("#6b03fc", "#4287f5", "#69b3a2", "#03fca1", "#dffc03", "#E8E8E8") )
my_cols <- c(ggplotColours(n = 5), "#E8E8E8") 
my_cols <- c("#F8766D","#A3A500" , "#69b3a2","#00B0F6", "#E76BF3", "#E8E8E8")

library(RColorBrewer)
# Tree colors
my_highlow <- c('#fc8d59','#ffffbf','#91bfdb')
```



